name: Deploy to AWS ECS

on:
  push:
    branches: [ aws, production ]
  workflow_run:
    workflows: ["Build and Test"]
    types:
      - completed
    branches: [ aws, production ]

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ap-southeast-1
  ECR_REPOSITORY_FRONTEND: nurtura-frontend
  ECR_REPOSITORY_WEBAPP: nurtura-webapp
  ECR_REPOSITORY_AI: nurtura-ai-moderation
  ECS_SERVICE_FRONTEND: nurtura-frontend-service
  ECS_SERVICE_WEBAPP: nurtura-webapp-service
  ECS_SERVICE_AI: nurtura-ai-service
  ECS_CLUSTER: nurtura-cluster
  ECS_TASK_DEFINITION_FRONTEND: nurtura-frontend-task
  ECS_TASK_DEFINITION_WEBAPP: nurtura-webapp-task
  ECS_TASK_DEFINITION_AI: nurtura-ai-task

jobs:
  check-ci-status:
    name: Verify CI Success
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    outputs:
      should-deploy: ${{ steps.check.outputs.deploy }}
    
    steps:
    - name: Check CI workflow result
      id: check
      run: |
        if [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
          echo "deploy=true" >> $GITHUB_OUTPUT
          echo "‚úÖ CI tests passed - proceeding with deployment"
        else
          echo "deploy=false" >> $GITHUB_OUTPUT
          echo "‚ùå CI tests failed - deployment aborted"
          exit 1
        fi

  check-infrastructure:
    name: Verify AWS Infrastructure
    runs-on: ubuntu-latest
    outputs:
      infrastructure-exists: ${{ steps.check.outputs.exists }}
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Check if infrastructure exists
      id: check
      run: |
        echo "üîç Checking if AWS infrastructure exists..."
        
        # Check ECR repositories
        FRONTEND_REPO=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY_FRONTEND --region $AWS_REGION 2>/dev/null || echo "NOT_FOUND")
        WEBAPP_REPO=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY_WEBAPP --region $AWS_REGION 2>/dev/null || echo "NOT_FOUND")
        AI_REPO=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY_AI --region $AWS_REGION 2>/dev/null || echo "NOT_FOUND")
        
        # Check ECS cluster
        CLUSTER_STATUS=$(aws ecs describe-clusters --clusters $ECS_CLUSTER --region $AWS_REGION --query 'clusters[0].status' --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$FRONTEND_REPO" == "NOT_FOUND" ]] || [[ "$WEBAPP_REPO" == "NOT_FOUND" ]] || [[ "$AI_REPO" == "NOT_FOUND" ]] || [[ "$CLUSTER_STATUS" == "NOT_FOUND" ]]; then
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "‚ùå Infrastructure not found. Please run the 'Create AWS Infrastructure' workflow first."
          echo ""
          echo "üìã Missing components:"
          [[ "$FRONTEND_REPO" == "NOT_FOUND" ]] && echo "  - ECR Repository: $ECR_REPOSITORY_FRONTEND"
          [[ "$WEBAPP_REPO" == "NOT_FOUND" ]] && echo "  - ECR Repository: $ECR_REPOSITORY_WEBAPP"
          [[ "$AI_REPO" == "NOT_FOUND" ]] && echo "  - ECR Repository: $ECR_REPOSITORY_AI"
          [[ "$CLUSTER_STATUS" == "NOT_FOUND" ]] && echo "  - ECS Cluster: $ECS_CLUSTER"
          echo ""
          echo "üèóÔ∏è To fix this:"
          echo "1. Go to Actions tab"
          echo "2. Run 'Create AWS Infrastructure' workflow"
          echo "3. Select staging or production environment"
          echo "4. Wait for completion"
          echo "5. Then re-run this deployment"
          exit 1
        else
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "‚úÖ All infrastructure components found"
          echo "  - ECR Repositories: ‚úÖ"
          echo "  - ECS Cluster: ‚úÖ ($CLUSTER_STATUS)"
        fi

  deploy:
    name: Build and Deploy to AWS
    runs-on: ubuntu-latest
    needs: [check-ci-status, check-infrastructure]
    if: |
      always() &&
      (needs.check-ci-status.result == 'skipped' || needs.check-ci-status.outputs.should-deploy == 'true') &&
      needs.check-infrastructure.outputs.infrastructure-exists == 'true' &&
      ((github.event_name == 'workflow_run' && needs.check-ci-status.outputs.should-deploy == 'true') ||
      (github.event_name == 'push' && (github.ref == 'refs/heads/aws' || github.ref == 'refs/heads/production')))

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js for build
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies for build
      run: |
        npm ci
        cd server && npm ci

    - name: Build frontend for production
      run: npm run build

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build, tag, and push Frontend image to Amazon ECR
      id: build-frontend-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build frontend image with production build
        docker build -f Dockerfile.frontend -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Frontend image built and pushed successfully"

    - name: Build, tag, and push WebApp image to Amazon ECR
      id: build-webapp-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build webapp image
        docker build -f server/Dockerfile.webapp -t $ECR_REGISTRY/$ECR_REPOSITORY_WEBAPP:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_WEBAPP:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_WEBAPP:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ WebApp image built and pushed successfully"

    - name: Build, tag, and push AI Moderation image to Amazon ECR
      id: build-ai-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build AI moderation image
        docker build -f automod/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY_AI:$IMAGE_TAG automod/
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_AI:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_AI:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ AI Moderation image built and pushed successfully"

    - name: Download current task definitions
      run: |
        # Download current task definitions with error handling
        echo "üì• Downloading current task definitions..."
        aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_FRONTEND --query taskDefinition > frontend-task-definition.json || echo "Warning: Frontend task definition not found, will create new one"
        aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_WEBAPP --query taskDefinition > webapp-task-definition.json || echo "Warning: WebApp task definition not found, will create new one"
        aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_AI --query taskDefinition > ai-task-definition.json || echo "Warning: AI task definition not found, will create new one"

    - name: Update Frontend task definition
      id: frontend-task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: frontend-task-definition.json
        container-name: nurtura-frontend
        image: ${{ steps.build-frontend-image.outputs.image }}

    - name: Update WebApp task definition
      id: webapp-task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: webapp-task-definition.json
        container-name: nurtura-webapp
        image: ${{ steps.build-webapp-image.outputs.image }}

    - name: Update AI Moderation task definition
      id: ai-task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: ai-task-definition.json
        container-name: nurtura-ai-moderation
        image: ${{ steps.build-ai-image.outputs.image }}

    - name: Deploy Frontend service to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.frontend-task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_FRONTEND }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Deploy WebApp service to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.webapp-task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_WEBAPP }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Deploy AI service to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.ai-task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_AI }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Verify Deployments
      run: |
        echo "üîç Verifying deployments..."
        
        # Check service status
        aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE_FRONTEND $ECS_SERVICE_WEBAPP $ECS_SERVICE_AI \
          --query 'services[*].[serviceName,status,runningCount,desiredCount]' --output table
        
        # Get load balancer endpoints if available
        echo "üì° Checking for load balancer endpoints..."
        aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE_FRONTEND \
          --query 'services[0].loadBalancers[0].targetGroupArn' --output text | grep -v None || echo "No load balancer configured"

    - name: Deployment Summary
      run: |
        echo "üöÄ Deployment Summary"
        echo "====================="
        echo "‚úÖ All tests passed in CI workflow"
        echo "‚úÖ All Docker images built and pushed:"
        echo "   üì¶ Frontend: ${{ steps.build-frontend-image.outputs.image }}"
        echo "   üì¶ WebApp: ${{ steps.build-webapp-image.outputs.image }}"
        echo "   üì¶ AI Service: ${{ steps.build-ai-image.outputs.image }}"
        echo ""
        echo "üèóÔ∏è ECS Deployment Details:"
        echo "   üåü Cluster: ${{ env.ECS_CLUSTER }}"
        echo "   üåç Region: ${{ env.AWS_REGION }}"
        echo "   üîß Services: ${{ env.ECS_SERVICE_FRONTEND }}, ${{ env.ECS_SERVICE_WEBAPP }}, ${{ env.ECS_SERVICE_AI }}"
        echo ""
        echo "‚úÖ All services deployed successfully to AWS ECS Fargate!"
        echo "üéâ Deployment completed at $(date)"
